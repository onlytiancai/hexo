---
title: '202410'
date: 2024-10-30 09:00:04
tags:
---
部分内容由 AI 生成
## 做一个大型fastapi项目的目录规划

在构建一个大型的 FastAPI 项目时，清晰的目录结构能帮助项目更加可维护、易于扩展，并且利于团队协作。以下是一个典型的目录规划：

```plaintext
my_fastapi_project/
├── app/
│   ├── __init__.py
│   ├── main.py               # FastAPI 的入口文件，创建 app 实例并启动服务
│   ├── core/                 # 核心配置模块
│   │   ├── __init__.py
│   │   ├── config.py         # 配置项（如数据库URL、环境变量等）
│   │   ├── security.py       # 安全相关设置（如加密、鉴权逻辑）
│   │   ├── logging.py        # 日志配置
│   ├── api/                  # API 路由模块
│   │   ├── __init__.py
│   │   ├── v1/               # API 版本 1
│   │   │   ├── __init__.py
│   │   │   ├── endpoints/    # 各个 API 端点
│   │   │   │   ├── __init__.py
│   │   │   │   ├── users.py  # 用户相关接口
│   │   │   │   ├── items.py  # 其他模块接口
│   │   │   └── dependencies/ # 依赖项（如权限验证）
│   ├── models/               # 数据库模型
│   │   ├── __init__.py
│   │   ├── user.py           # 用户模型
│   │   ├── item.py           # 其他模型
│   ├── schemas/              # Pydantic 模式（用于数据验证）
│   │   ├── __init__.py
│   │   ├── user.py           # 用户相关数据模式
│   │   ├── item.py           # 其他模块的数据模式
│   ├── crud/                 # 数据库 CRUD 操作
│   │   ├── __init__.py
│   │   ├── user.py           # 用户相关的 CRUD 操作
│   │   ├── item.py           # 其他模块的 CRUD 操作
│   ├── db/                   # 数据库相关
│   │   ├── __init__.py
│   │   ├── base.py           # 数据库基础设置
│   │   ├── session.py        # 数据库会话管理
│   │   └── init_db.py        # 数据库初始化脚本
│   ├── services/             # 独立业务逻辑模块
│   │   ├── __init__.py
│   │   ├── user_service.py   # 用户相关业务逻辑
│   │   ├── email_service.py  # 邮件相关逻辑
│   ├── tests/                # 测试用例
│   │   ├── __init__.py
│   │   ├── test_main.py      # 主入口测试
│   │   ├── test_user.py      # 用户模块测试
│   │   ├── test_item.py      # 其他模块测试
├── alembic/                  # 数据库迁移目录
│   ├── versions/             # 迁移脚本版本
│   └── alembic.ini           # alembic 配置文件
├── scripts/                  # 辅助脚本
│   ├── create_superuser.py   # 创建超级用户脚本
│   ├── init_data.py          # 初始化数据脚本
├── .env                      # 环境变量配置文件
├── Dockerfile                # Docker 镜像配置
├── docker-compose.yml        # Docker Compose 配置
├── requirements.txt          # Python 依赖包列表
├── README.md                 # 项目说明文件
└── .gitignore                # Git 忽略文件
```

### 目录结构说明

1. **app/main.py**: 项目入口文件，创建 FastAPI 实例并定义启动流程。
2. **app/core/**: 存放核心配置、日志、安全配置等。
3. **app/api/**: 各个 API 版本的具体实现，可以通过 `v1` 等目录区分不同的版本，便于后续扩展。
4. **app/models/**: 定义数据库模型。
5. **app/schemas/**: 存放 Pydantic 数据验证模型，用于请求和响应数据的结构验证。
6. **app/crud/**: 提供数据库 CRUD 操作，封装直接操作数据库的逻辑。
7. **app/db/**: 数据库的初始化和会话管理。
8. **app/services/**: 存放业务逻辑，与 API 和数据库层解耦。
9. **app/tests/**: 包含所有测试用例，可以细分为各个模块的单元测试和集成测试。
10. **alembic/**: 数据库迁移工具 `Alembic` 的配置及版本文件。
11. **scripts/**: 包含辅助管理脚本，如创建超级用户或初始化数据的脚本。
12. **Dockerfile & docker-compose.yml**: Docker 配置，便于容器化部署。
13. **.env**: 存储环境变量，保证敏感信息不直接写入代码。
14. **requirements.txt**: 列出项目依赖的第三方包，便于环境一致性。

### 实现思路
- **解耦**：各层之间使用依赖注入，服务与接口层解耦，使业务逻辑更易于测试和复用。
- **安全性**：将 `.env` 与 `app/core/config.py` 结合使用，通过环境变量管理敏感信息。
- **模块化**：将每个功能模块（如用户、项目等）封装为 CRUD、schema、model、service 等子模块，便于快速定位和调试。

## 更好的 grep

grep 一个目录下的所有文件，但忽略.git目录和二进制文件

要在一个目录下递归地搜索文本，同时忽略 `.git` 目录和二进制文件，可以使用以下 `grep` 命令：

```bash
grep -rI --exclude-dir='.git' 'search_term' /path/to/directory
```

### 参数说明
- **-r**: 递归搜索，遍历子目录中的所有文件。
- **-I**: 忽略二进制文件。`grep` 会自动跳过二进制文件，减少干扰。
- **--exclude-dir='.git'**: 忽略 `.git` 目录中的内容。你可以添加多个 `--exclude-dir` 参数来排除多个目录。

### 示例
假设你想在 `/home/user/project` 目录中查找包含 `TODO` 的文件，但忽略 `.git` 目录和二进制文件：

```bash
grep -rI --exclude-dir='.git' 'TODO' /home/user/project
```

这个命令会递归地在 `/home/user/project` 目录下的所有文件中查找包含 `TODO` 的文本，跳过 `.git` 目录和所有二进制文件。

## 统计每行的逗号

在 Shell 中可以使用 `awk` 或 `grep` 来统计每一行中逗号的个数。以下是几种实现方法：

### 方法 1：使用 `awk`
```bash
awk -F"," '{print NR, ":", NF-1}' filename
```

- **-F","**：指定逗号作为字段分隔符。
- **NF-1**：`NF` 表示字段的数量，`NF-1` 就是逗号的个数。
- **NR**：表示当前行号。

输出示例：
```
1 : 3
2 : 5
...
```

### 方法 2：使用 `grep` 和 `sed`
```bash
grep -o "," filename | wc -l
```

这个命令适合统计文件中所有行的逗号总数，若需要按行统计，则可结合 `while` 循环：

```bash
while IFS= read -r line; do
    echo "$line" | grep -o "," | wc -l
done < filename
```

### 方法 3：使用 `sed`
```bash
sed 's/[^,]//g' filename | awk '{print length}'
```

这将每一行中非逗号的内容替换为空，然后用 `awk` 统计字符长度。

tailwind 资源
https://tailadmin.com/

23 Tailwind Dashboards
https://freefrontend.com/tailwind-dashboards/

A free repository for community components using Tailwind CSS
https://www.creative-tim.com/twcomponents


14 Best Free Bootstrap Admin Templates 2024
https://athemes.com/collections/free-bootstrap-admin-templates/


当指定view为flex布局后，给子元素定义width是不起效果的。原因：定义为flex布局元素的子元素，自动获得了flex-shrink的属性，这个属性是什么意思呢？就是告诉子元素当父元素宽度不够用时，自己调整自己所占的宽度比，这个flex-shrink设置为1时，表示所有子元素大家同时缩小来适应总宽度。当flex-shrink设置为0时，表示大家都不缩小适应。所以，倘若给父元素设置了flex布局后，若要其子元素的width有效果，必须给子元素设置flex-shrink为0。

原文链接：https://blog.csdn.net/weixin_51725685/article/details/129310089

Twemproxy 在实际线的使用中，还是存在不少问题的。首先，它是单进程/单线程模型，一个 event_base 要处理所有的事件，这些事件包括 client 请求的读入，转发请求给后端 server，从 server 接受响应，以及将响应发送给 client。单个 Twemproxy 实例，压测最大可以到 8w 左右的 QPS，出于线上稳定性考虑，QPS 最多支撑到 3~4w。而 Memcached 的线上 QPS，一般可以达到 10~20w，一个 Mc 实例前面要挂 3~5 个 Twemproxy 实例。实例数太多，就会引发诸如管理复杂、成本过高等一系列问题。
————————————————
原文链接：https://blog.csdn.net/zhougubei/article/details/139147401

Redis 中有哪些概率性数据结构
https://blog.axiaoxin.com/post/redis-bloom-filter-intro/

概率性数据结构（Probabilistic data structures）是一类用于处理大规模数据集的高效工具，它们通过近似统计结果，如计数、频率和排名等，来替代精确值。虽然这些近似结果并不精确，但它们在许多常见场景中已足够使用，且计算效率更高。此外，这类数据结构还具有其他优势，例如能够模糊化时间、位置等敏感数据。

Redis 常见的概率性数据结构：
- HyperLogLog：一种用于估算集合基数的概率性数据结构，非常适合用于估算大规模集合的基数，而不需要存储所有元素。
- Bloom Filter：一种用于检查集合中是否存在某个元素的概率性数据结构，非常适合在大规模数据集中进行快速查询和过滤操作。
- Cuckoo Filter：一种支持删除操作的概率性数据结构，能够在一定程度上降低误判率，适用于需要更高准确度和支持元素删除的场景。
- t-digest：一种用于估算数据流中百分位数的概率性数据结构，特别适合处理大规模数据流。
- Top-K：一种用于找出数据流中最频繁出现项的概率性数据结构，适用于需要实时分析数据流中的热门项的场景。
- Count-min sketch：一种用于估算数据流中元素频率的概率性数据结构，适用于大规模数据流的频率分析。

选择指南
- 如果需要快速判断元素是否存在于集合中，并且不需要删除操作，Bloom Filter 是一个极佳的选择。
- 如果需要检查元素存在性且支持删除操作，Cuckoo Filter 更为适合。
- 对于估算集合基数，HyperLogLog 是最佳工具。
- 如果需要实时估算数据流中的百分位数，t-digest 是最佳选择。
- 若要找出数据流中的最常见元素，Top-K 是最合适的选择。
- 当需要快速估算数据流中元素的频率时，Count-min Sketch 是理想工具。
